### 트랜잭션과 락

> **트랜잭션과 격리 수준**

- 트랜잭션 기초와 JPA가 제공하는 낙관적인 락과 비관적인 락에 대한 정리

> **트랜잭션의 특성**

트랜잭션은 `ACID`라 하는 원자성, 일관성, 격리성, 지속성을 보장해야 한다.

- `원자성`:
    - 트랜잭션내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 `성공` 하든가 모두 `실패`해야 한다.
- `일관성`:
    - 모든 트랜잭션은 `일관성`있는 데이터베이스 상태를 유지해야한다.
    - 예를 들어 데이터베이스에서 정한 `무결성 제약 조건`을 항상 만족해야 한다.
- `격리성`:
    - 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
    - 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다.
    - `격리성`은 `동시성과 관련된 성능 이슈`로 인해 `격리 수준을 선택`할 수 있다.
- `지속성`:
    - 트랜잭션을 성공적으로 끝내면 그 `결과`가 `항상 기록`되어야 한다.
    - 중간에 `시스템에 문제가 발생`해도 데이터베이스 로그 등을 사용해서 `성공한 트랜잭션 내용을 복구`해야 한다.

* 여기서 중요한 점은 `트랜잭션 간`에 `격리성을 완벽히 보장`하기 위해서는 트랜잭션을 차례로 실행해야 하고, 그렇게 되면 `동시성 처리 성능`이 나빠진다.
* 그리하여 `트랜잭션의 격리 레벨에 대한 이해`와 `동시성에 대한 문제를 해결`하는 방법에 대해 알아야 한다.

> **트랜잭션과 격리 수준**

- **READ UNCOMMITED(커밋되지않은 읽기)**
    - 커밋하지 않은 데이터를 읽을 수 있다.
    - 트랜잭션 A 가 데이터를 수정하고 있는 와중에 `COMMIT`을 하지 않아도 트랜잭션 B가 수정 중인 데이터를 볼 수 있다.
    - 이를 `DIRTY READ`라 하고, 데이터 정합성에 심각한 문제가 발생할 수 있다.

- **READ COMMITTED(커밋된 읽기)**
    - 커밋한 데이터만 읽을 수 있다.
    - 커밋한 데이터만 볼 수 있기 때문에 `DIRTY READ` 현상이 발생하지 않는다.
    - 하지만 `NON-REPEATABLE READ`는 발생할 수 있다.
    - 트랜잭션 A가 회원 1을 조회 중인데, 그 순간에 트랜잭션 B가 회원 1을 수정하고 `COMMIT`하는 경우 트랜잭션 A가 다시 회원을 조회 하였을 때 수정된 데이터가 조회된다.
    - 이처럼 반복해서 같은 데이터를 읽을 수 없는 상태를 `NON-REPEATABLE READ`라 한다.
    - `DIRTY-READ`는 허용하지만, `NON-REPEATABLE READ`는 허용하는 격리 수준을 `READ COMMITED`라 한다.

- **REPEATABLE READ(반복가능한 읽기)**
    - 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다.
    - 하지만 `PHANTOM READ`가 발생할 수 있다.
    - 트랜잭션 A가 회원 10 살 이하의 회원을 조회 했는데 트랜잭션 B가 5살 회원을 추가하고 커밋하면, 트랜잭션 A가 다시 10살 이하의 회원을 조회하는 경우 회원 하나가 추가된 상태로 조회된다.
    - 이처럼 반복 조회 시 결과 집합이 달라지는 것을 `PHANTOM READ`라 한다.
    - `NON-REPEATABLE READ`는 허용하지 않지만, `PHANTOM READ`는 허 용하는 격리 수준을 `REPEATABLE READ`라 한다.

- **SERIALIZABLE(직렬화 가능)**
    - 가장 엄격한 트랜잭션 격리 수준이다.
    - `PHANTOM READ`가 발생하지 않는다. 하지만 `동시성 처리 성능`이 급격히 떨어질 수 있다.

> **격리 수준에 대한 고민하기**

어플리케이션 대부분은 `동시성 처리`가 중요하므로 `READ COMMITED`의 격리 수준을 기본으로 사용한다.

기본은 `READ COMMITED`로 두고 더 높은 격리 수준이 필요한 경우 `데이터베이스 트랜잭션이 제공하는 잠금 기능`을 사용하는 방식을 쓴다.

